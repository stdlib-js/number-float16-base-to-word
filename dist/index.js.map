{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar NINF = require( '@stdlib/constants-float16-ninf' );\nvar PINF = require( '@stdlib/constants-float16-pinf' );\nvar isnanf = require( '@stdlib/math-base-assert-is-nanf' );\nvar absf = require( '@stdlib/math-base-special-absf' );\nvar exponent = require( '@stdlib/number-float32-base-exponent' );\nvar isNegativeZerof = require( '@stdlib/math-base-assert-is-negative-zerof' );\nvar FLOAT32_SIGNIFICAND_MASK = require( '@stdlib/constants-float32-significand-mask' );\nvar toWordf = require( '@stdlib/number-float32-base-to-word' );\n\n\n// VARIABLES //\n\nvar UINT16_NAN = 0x7E00;                    // 0x7E00 = 32256 => 0 11111 1000000000\nvar UINT16_PINF = 0x7C00;                   // 0x7C00 = 31744 => 0 11111 0000000000\nvar UINT16_NINF = 0xFC00;                   // 0xFC00 = 64512 => 1 11111 0000000000\nvar UINT16_POSITIVE_ZERO = 0x0000;          // 0x0000 = 0 => 0 00000 0000000000\nvar UINT16_NEGATIVE_ZERO = 0x8000;          // 0x8000 = 32768 => 1 00000 0000000000\nvar FLOAT32_IMPLICIT_BIT = 0x800000;        // 0x800000 = 8388608 => 0 00000001 00000000000000000000000\nvar FLOAT32_SUBNORMAL_STICKY_MASK = 0x1FFF; // 0x1FFF = 8191 => 0 00000000 00000000001111111111111\nvar FLOAT32_STICKY_MASK = 0xFFF;            // 0xFFF = 4095 => 0 00000000 00000000000111111111111\nvar MAX_MANTISSA = 0x3FF;                   // 0x3FF = 1023 => 0 00000 1111111111\n\n\n// MAIN //\n\n/**\n* Returns an unsigned 16-bit integer corresponding to the IEEE 754 binary representation of a half-precision floating-point number.\n*\n* @param {number} x - half-precision floating-point number\n* @returns {unsigned16} unsigned 16-bit integer\n*\n* @example\n* var float64ToFloat16 = require( '@stdlib/number-float64-base-to-float16' );\n*\n* var f16 = float64ToFloat16( 1.05 );\n* // returns 1.0498046875\n*\n* var w = toWord( f16 ); // => 0 01111 0000110011\n* // returns 15411\n*/\nfunction toWord( x ) {\n\tvar f32Exponent;\n\tvar f16Exponent;\n\tvar stickyBits;\n\tvar mantissa;\n\tvar roundBit;\n\tvar shift;\n\tvar bits;\n\tvar mant;\n\tvar sign;\n\n\t// Handle special cases...\n\tif ( isnanf( x ) ) {\n\t\treturn UINT16_NAN;\n\t}\n\tif ( x === PINF ) {\n\t\treturn UINT16_PINF; // +Infinity\n\t}\n\tif ( x === NINF ) {\n\t\treturn UINT16_NINF; // -Infinity\n\t}\n\tif ( x === 0 ) {\n\t\tif ( isNegativeZerof( x ) ) {\n\t\t\treturn UINT16_NEGATIVE_ZERO;\n\t\t}\n\t\treturn UINT16_POSITIVE_ZERO;\n\t}\n\tif ( x < 0 ) {\n\t\tsign = 1;\n\t} else {\n\t\tsign = 0;\n\t}\n\tx = absf( x );\n\tbits = toWordf( x );\n\n\tmant = bits & FLOAT32_SIGNIFICAND_MASK; // 23-bit mantissa\n\n\t// Store unbiased exponent of a 32-bit floating-point number:\n\tf32Exponent = exponent( x );\n\n\t// Calculate exponent of a 16-bit floating-point number:\n\tf16Exponent = f32Exponent + 15;\n\n\t// Handle overflow (infinity in float16)...\n\tif ( f16Exponent >= 31 ) {\n\t\tif ( sign ) {\n\t\t\treturn UINT16_NINF; // -Infinity\n\t\t}\n\t\treturn UINT16_PINF; // +Infinity\n\t}\n\t// Handle underflow (subnormal or zero in float16)...\n\tif ( f16Exponent <= 0 ) {\n\t\t// Check if the value is too small to be represented even as a subnormal float16 number:\n\t\tif ( f16Exponent < -10 ) {\n\t\t\treturn sign << 15; // return zero with the appropriate sign bit\n\t\t}\n\t\t// Calculate the amount of right shift needed to denormalize the mantissa for subnormal representation:\n\t\tshift = 1 - f16Exponent;\n\n\t\t// Create an 11-bit mantissa by adding the implicit leading 1 bit and extracting the top 10 bits from mantissa:\n\t\tmantissa = ( FLOAT32_IMPLICIT_BIT | mant ) >>> 13;\n\n\t\t// Determine the round bit and sticky bits based on the shift amount to apply correct rounding...\n\t\tif ( shift < 11 ) {\n\t\t\t// Extract the round bit at the position that will be truncated after the shift:\n\t\t\troundBit = ( mantissa >>> ( shift - 1 ) ) & 1;\n\n\t\t\t// Check if any bits below the round bit position are set (sticky bits):\n\t\t\tstickyBits = ( mantissa & ( ( 1 << ( shift - 1 ) ) - 1 ) ) !== 0;\n\n\t\t\t// If no sticky bits found in the 11-bit mantissa, check the remaining bits from the original mantissa:\n\t\t\tif ( !stickyBits ) {\n\t\t\t\tstickyBits = ( mant & FLOAT32_SUBNORMAL_STICKY_MASK ) !== 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// When the shift is 11 or greater, the round bit comes from original mantissa:\n\t\t\troundBit = ( mant >>> ( 13 - ( shift - 11 ) - 1 ) ) & 1;\n\n\t\t\t// Check if any bits below the round bit position in mantissa are set:\n\t\t\tstickyBits = ( mant & ( ( 1 << ( 13 - ( shift - 11 ) - 1 ) ) - 1 ) ) !== 0; // eslint-disable-line max-len\n\t\t}\n\t\t// Apply the denormalization shift to the mantissa:\n\t\tmantissa >>>= shift;\n\n\t\t// Round to nearest even:\n\t\tif ( roundBit && ( stickyBits || ( mantissa & 1 ) ) ) {\n\t\t\tmantissa += 1;\n\t\t}\n\t\treturn ( sign << 15 ) | mantissa;\n\t}\n\t// Extract the top 10 bits of the mantissa from 23 bits:\n\tmantissa = mant >>> 13;\n\n\t// Extract the round bit (the first bit that will be truncated):\n\troundBit = ( mant >>> 12 ) & 1;\n\n\t// Check sticky bits (all bits below bit 12):\n\tstickyBits = ( mant & FLOAT32_STICKY_MASK ) !== 0;\n\n\t// Round up if roundBit is 1 AND (sticky bits OR mantissa is odd):\n\tif ( roundBit && ( stickyBits || ( mantissa & 1 ) ) ) {\n\t\tmantissa += 1;\n\n\t\t// Check for mantissa overflow (carries into exponent)...\n\t\tif ( mantissa > MAX_MANTISSA ) {\n\t\t\tf16Exponent += 1;\n\t\t\tmantissa = 0;\n\n\t\t\t// Check for exponent overflow...\n\t\t\tif ( f16Exponent >= 31 ) {\n\t\t\t\tif ( sign ) {\n\t\t\t\t\treturn UINT16_NINF; // -Infinity\n\t\t\t\t}\n\t\t\t\treturn UINT16_PINF; // +Infinity\n\t\t\t}\n\t\t}\n\t}\n\t// Combine sign (1 bit), exponent (5 bits), and mantissa (10 bits):\n\treturn ( sign << 15 ) | ( f16Exponent << 10 ) | mantissa;\n}\n\n\n// EXPORTS //\n\nmodule.exports = toWord;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Return an unsigned 16-bit integer corresponding to the IEEE 754 binary representation of a half-precision floating-point number.\n*\n* @module @stdlib/number-float16-base-to-word\n*\n* @example\n* var float64ToFloat16 = require( '@stdlib/number-float64-base-to-float16' );\n* var toWord = require( '@stdlib/number-float16-base-to-word' );\n*\n* var f16 = float64ToFloat16( 1.05 );\n* // returns 1.0498046875\n*\n* var w = toWord( f16 ); // => 0 01111 0000110011\n* // returns 15411\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,gCAAiC,EACjDC,EAAS,QAAS,kCAAmC,EACrDC,EAAO,QAAS,gCAAiC,EACjDC,EAAW,QAAS,sCAAuC,EAC3DC,EAAkB,QAAS,4CAA6C,EACxEC,EAA2B,QAAS,4CAA6C,EACjFC,EAAU,QAAS,qCAAsC,EAKzDC,EAAa,MACbC,EAAc,MACdC,EAAc,MACdC,EAAuB,EACvBC,EAAuB,MACvBC,EAAuB,QACvBC,EAAgC,KAChCC,EAAsB,KACtBC,EAAe,KAoBnB,SAASC,EAAQC,EAAI,CACpB,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAGJ,OAAKzB,EAAQgB,CAAE,EACPV,EAEHU,IAAMjB,EACHQ,EAEHS,IAAMlB,EACHU,EAEHQ,IAAM,EACLb,EAAiBa,CAAE,EAChBN,EAEDD,GAEHO,EAAI,EACRS,EAAO,EAEPA,EAAO,EAERT,EAAIf,EAAMe,CAAE,EACZO,EAAOlB,EAASW,CAAE,EAElBQ,EAAOD,EAAOnB,EAGda,EAAcf,EAAUc,CAAE,EAG1BE,EAAcD,EAAc,GAGvBC,GAAe,GACdO,EACGjB,EAEDD,EAGHW,GAAe,EAEdA,EAAc,IACXO,GAAQ,IAGhBH,EAAQ,EAAIJ,EAGZE,GAAaT,EAAuBa,KAAW,GAG1CF,EAAQ,IAEZD,EAAaD,IAAeE,EAAQ,EAAQ,EAG5CH,GAAeC,GAAe,GAAOE,EAAQ,GAAQ,KAAU,EAGzDH,IACLA,GAAeK,EAAOZ,KAAoC,KAI3DS,EAAaG,IAAW,IAAOF,EAAQ,IAAO,EAAQ,EAGtDH,GAAeK,GAAW,GAAO,IAAOF,EAAQ,IAAO,GAAQ,KAAU,GAG1EF,KAAcE,EAGTD,IAAcF,GAAgBC,EAAW,KAC7CA,GAAY,GAEJK,GAAQ,GAAOL,IAGzBA,EAAWI,IAAS,GAGpBH,EAAaG,IAAS,GAAO,EAG7BL,GAAeK,EAAOX,KAA0B,EAG3CQ,IAAcF,GAAgBC,EAAW,KAC7CA,GAAY,EAGPA,EAAWN,IACfI,GAAe,EACfE,EAAW,EAGNF,GAAe,KACdO,EACGjB,EAEDD,EAKDkB,GAAQ,GAASP,GAAe,GAAOE,GACjD,CAKAvB,EAAO,QAAUkB,ICpJjB,IAAIW,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "NINF", "PINF", "isnanf", "absf", "exponent", "isNegativeZerof", "FLOAT32_SIGNIFICAND_MASK", "toWordf", "UINT16_NAN", "UINT16_PINF", "UINT16_NINF", "UINT16_POSITIVE_ZERO", "UINT16_NEGATIVE_ZERO", "FLOAT32_IMPLICIT_BIT", "FLOAT32_SUBNORMAL_STICKY_MASK", "FLOAT32_STICKY_MASK", "MAX_MANTISSA", "toWord", "x", "f32Exponent", "f16Exponent", "stickyBits", "mantissa", "roundBit", "shift", "bits", "mant", "sign", "main"]
}
