{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport NINF from '@stdlib/constants-float16-ninf';\nimport PINF from '@stdlib/constants-float16-pinf';\nimport isnanf from '@stdlib/math-base-assert-is-nanf';\nimport absf from '@stdlib/math-base-special-absf';\nimport exponent from '@stdlib/number-float32-base-exponent';\nimport isNegativeZerof from '@stdlib/math-base-assert-is-negative-zerof';\nimport FLOAT32_SIGNIFICAND_MASK from '@stdlib/constants-float32-significand-mask';\nimport toWordf from '@stdlib/number-float32-base-to-word';\n\n\n// VARIABLES //\n\nvar UINT16_NAN = 0x7E00;                    // 0x7E00 = 32256 => 0 11111 1000000000\nvar UINT16_PINF = 0x7C00;                   // 0x7C00 = 31744 => 0 11111 0000000000\nvar UINT16_NINF = 0xFC00;                   // 0xFC00 = 64512 => 1 11111 0000000000\nvar UINT16_POSITIVE_ZERO = 0x0000;          // 0x0000 = 0 => 0 00000 0000000000\nvar UINT16_NEGATIVE_ZERO = 0x8000;          // 0x8000 = 32768 => 1 00000 0000000000\nvar FLOAT32_IMPLICIT_BIT = 0x800000;        // 0x800000 = 8388608 => 0 00000001 00000000000000000000000\nvar FLOAT32_SUBNORMAL_STICKY_MASK = 0x1FFF; // 0x1FFF = 8191 => 0 00000000 00000000001111111111111\nvar FLOAT32_STICKY_MASK = 0xFFF;            // 0xFFF = 4095 => 0 00000000 00000000000111111111111\nvar MAX_MANTISSA = 0x3FF;                   // 0x3FF = 1023 => 0 00000 1111111111\n\n\n// MAIN //\n\n/**\n* Returns an unsigned 16-bit integer corresponding to the IEEE 754 binary representation of a half-precision floating-point number.\n*\n* @param {number} x - half-precision floating-point number\n* @returns {unsigned16} unsigned 16-bit integer\n*\n* @example\n* import float64ToFloat16 from '@stdlib/number-float64-base-to-float16';\n*\n* var f16 = float64ToFloat16( 1.05 );\n* // returns 1.0498046875\n*\n* var w = toWord( f16 ); // => 0 01111 0000110011\n* // returns 15411\n*/\nfunction toWord( x ) {\n\tvar f32Exponent;\n\tvar f16Exponent;\n\tvar stickyBits;\n\tvar mantissa;\n\tvar roundBit;\n\tvar shift;\n\tvar bits;\n\tvar mant;\n\tvar sign;\n\n\t// Handle special cases...\n\tif ( isnanf( x ) ) {\n\t\treturn UINT16_NAN;\n\t}\n\tif ( x === PINF ) {\n\t\treturn UINT16_PINF; // +Infinity\n\t}\n\tif ( x === NINF ) {\n\t\treturn UINT16_NINF; // -Infinity\n\t}\n\tif ( x === 0 ) {\n\t\tif ( isNegativeZerof( x ) ) {\n\t\t\treturn UINT16_NEGATIVE_ZERO;\n\t\t}\n\t\treturn UINT16_POSITIVE_ZERO;\n\t}\n\tif ( x < 0 ) {\n\t\tsign = 1;\n\t} else {\n\t\tsign = 0;\n\t}\n\tx = absf( x );\n\tbits = toWordf( x );\n\n\tmant = bits & FLOAT32_SIGNIFICAND_MASK; // 23-bit mantissa\n\n\t// Store unbiased exponent of a 32-bit floating-point number:\n\tf32Exponent = exponent( x );\n\n\t// Calculate exponent of a 16-bit floating-point number:\n\tf16Exponent = f32Exponent + 15;\n\n\t// Handle overflow (infinity in float16)...\n\tif ( f16Exponent >= 31 ) {\n\t\tif ( sign ) {\n\t\t\treturn UINT16_NINF; // -Infinity\n\t\t}\n\t\treturn UINT16_PINF; // +Infinity\n\t}\n\t// Handle underflow (subnormal or zero in float16)...\n\tif ( f16Exponent <= 0 ) {\n\t\t// Check if the value is too small to be represented even as a subnormal float16 number:\n\t\tif ( f16Exponent < -10 ) {\n\t\t\treturn sign << 15; // return zero with the appropriate sign bit\n\t\t}\n\t\t// Calculate the amount of right shift needed to denormalize the mantissa for subnormal representation:\n\t\tshift = 1 - f16Exponent;\n\n\t\t// Create an 11-bit mantissa by adding the implicit leading 1 bit and extracting the top 10 bits from mantissa:\n\t\tmantissa = ( FLOAT32_IMPLICIT_BIT | mant ) >>> 13;\n\n\t\t// Determine the round bit and sticky bits based on the shift amount to apply correct rounding...\n\t\tif ( shift < 11 ) {\n\t\t\t// Extract the round bit at the position that will be truncated after the shift:\n\t\t\troundBit = ( mantissa >>> ( shift - 1 ) ) & 1;\n\n\t\t\t// Check if any bits below the round bit position are set (sticky bits):\n\t\t\tstickyBits = ( mantissa & ( ( 1 << ( shift - 1 ) ) - 1 ) ) !== 0;\n\n\t\t\t// If no sticky bits found in the 11-bit mantissa, check the remaining bits from the original mantissa:\n\t\t\tif ( !stickyBits ) {\n\t\t\t\tstickyBits = ( mant & FLOAT32_SUBNORMAL_STICKY_MASK ) !== 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// When the shift is 11 or greater, the round bit comes from original mantissa:\n\t\t\troundBit = ( mant >>> ( 13 - ( shift - 11 ) - 1 ) ) & 1;\n\n\t\t\t// Check if any bits below the round bit position in mantissa are set:\n\t\t\tstickyBits = ( mant & ( ( 1 << ( 13 - ( shift - 11 ) - 1 ) ) - 1 ) ) !== 0; // eslint-disable-line max-len\n\t\t}\n\t\t// Apply the denormalization shift to the mantissa:\n\t\tmantissa >>>= shift;\n\n\t\t// Round to nearest even:\n\t\tif ( roundBit && ( stickyBits || ( mantissa & 1 ) ) ) {\n\t\t\tmantissa += 1;\n\t\t}\n\t\treturn ( sign << 15 ) | mantissa;\n\t}\n\t// Extract the top 10 bits of the mantissa from 23 bits:\n\tmantissa = mant >>> 13;\n\n\t// Extract the round bit (the first bit that will be truncated):\n\troundBit = ( mant >>> 12 ) & 1;\n\n\t// Check sticky bits (all bits below bit 12):\n\tstickyBits = ( mant & FLOAT32_STICKY_MASK ) !== 0;\n\n\t// Round up if roundBit is 1 AND (sticky bits OR mantissa is odd):\n\tif ( roundBit && ( stickyBits || ( mantissa & 1 ) ) ) {\n\t\tmantissa += 1;\n\n\t\t// Check for mantissa overflow (carries into exponent)...\n\t\tif ( mantissa > MAX_MANTISSA ) {\n\t\t\tf16Exponent += 1;\n\t\t\tmantissa = 0;\n\n\t\t\t// Check for exponent overflow...\n\t\t\tif ( f16Exponent >= 31 ) {\n\t\t\t\tif ( sign ) {\n\t\t\t\t\treturn UINT16_NINF; // -Infinity\n\t\t\t\t}\n\t\t\t\treturn UINT16_PINF; // +Infinity\n\t\t\t}\n\t\t}\n\t}\n\t// Combine sign (1 bit), exponent (5 bits), and mantissa (10 bits):\n\treturn ( sign << 15 ) | ( f16Exponent << 10 ) | mantissa;\n}\n\n\n// EXPORTS //\n\nexport default toWord;\n"],"names":["UINT16_PINF","UINT16_NINF","toWord","x","f16Exponent","stickyBits","mantissa","roundBit","shift","mant","sign","isnanf","PINF","NINF","isNegativeZerof","absf","toWordf","FLOAT32_SIGNIFICAND_MASK","exponent"],"mappings":";;6yBAkCA,IACIA,EAAc,MACdC,EAAc,MA0BlB,SAASC,EAAQC,GAChB,IACIC,EACAC,EACAC,EACAC,EACAC,EAEAC,EACAC,EAGJ,OAAKC,EAAQR,GAxCG,MA2CXA,IAAMS,EACHZ,EAEHG,IAAMU,EACHZ,EAEG,IAANE,EACCW,EAAiBX,GA9CG,MADA,GAqDzBO,EADIP,EAAI,EACD,EAEA,EAERA,EAAIY,EAAMZ,GAGVM,EAFOO,EAASb,GAEFc,GAMdb,EAHcc,EAAUf,GAGI,KAGR,GACdO,EACGT,EAEDD,EAGHI,GAAe,EAEdA,GAAe,GACZM,GAAQ,IAMhBJ,GAnFyB,QAmFWG,KAAW,IAH/CD,EAAQ,EAAIJ,GAMC,IAEZG,EAAaD,IAAeE,EAAQ,EAAQ,GAG5CH,EAA+D,IAAhDC,GAAe,GAAOE,EAAQ,GAAQ,MAIpDH,EAA0D,IA9F1B,KA8FjBI,MAIhBF,EAAaE,IAAW,IAAOD,EAAQ,IAAO,EAAQ,EAGtDH,EAAyE,IAA1DI,GAAW,GAAO,IAAOD,EAAQ,IAAO,GAAQ,IAGhEF,KAAcE,EAGTD,IAAcF,GAA2B,EAAXC,KAClCA,GAAY,GAEJI,GAAQ,GAAOJ,IAGzBA,EAAWG,IAAS,GAMpBJ,EAAgD,IAtHvB,KAsHVI,IAHfF,EAAaE,IAAS,GAAO,KAMVJ,GAA2B,EAAXC,KAClCA,GAAY,GAzHK,OA8HhBA,EAAW,GADXF,GAAe,IAIK,IACdM,EACGT,EAEDD,EAKDU,GAAQ,GAASN,GAAe,GAAOE,GACjD"}